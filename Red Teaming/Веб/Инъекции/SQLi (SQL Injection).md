SQL-инъекция - это уязвимость веб-безопасности, позволяющая атакующему изменять запросы, которые приложение отправляет к своей базе данных
## Источники информации
- [SQL injection Topic PortSwigger Academy](https://portswigger.net/web-security/authentication)
- База знаний: https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL%20Injection
## Инструменты
- [sqlmap](https://github.com/sqlmapproject/sqlmap): `sqlmap -u <url> --data <login=1&password=1>`
## Обнаружение SQLi
- Вставка специальных символов в значение параметров: `'`, `"`, `\`
- Булевы условия: `OR 1=1`, `OR 1=2`
- Полезные нагрузки, осуществляющие временные задержки
- Полезные нагрузки OAST (Out-of-Band Application Security Testing), осуществляющие обращение ко внешним ресурсам
## Места запроса, где возникает SQLi
- Оператор `SELECT`: оператор `WHERE`, оператор `ORDER BY`, имя таблицы, имя столбца
- Оператор `UPDATE`: обновляемые значения, оператор `WHERE
- Оператор `INSERT`: вставляемые значения
## Общая информация
- Внедрение выражения `' or 1=1--` делает следующий SQL-запрос `SELECT <columns> FROM <table_name> WHERE <some_column> = '' or 1=1--`, что приводит к получению значений всех строк из таблицы, так как `1=1` всегда `true`
- Атакующий может обойти аутентификацию, если SQL-запрос в таблицу с пользователями уязвим. Внедрение `--` после значения логина позволит обойти проверку пароля (`SELECT * FROM users WHERE username = 'administrator'--' AND password = ''`)
## Виды
### Union-based
Когда приложение уязвимо для SQL-инъекций и результаты запроса возвращаются в ответах приложения, атакующий может использовать оператор UNION для извлечения данных из других таблиц в базе данных. Пример запроса с оператором UNION: `SELECT a, b FROM table1 UNION SELECT c, d FROM table2` (запрос вернет столбцы `a` и `c` в виде одного столбца, `b` и `d` в виде одного столбца)
#### Условия выполнения Union-based SQLi:
- В объединяемых запросах одинаковое количество столбцов
- Типы данных в соответствующих столбцах должны быть совместимы (значение `NULL` совместимо со всеми типами данных)
#### Определение количества столбцов
- Можно использовать оператор ORDER BY с целью сортировки выходных данных по одному из столбцов. К столбцам можно обращаться по индексам (1, 2, 3, ...). Увеличивая индексы, когда будет сделана попытка отсортировать данные по столбцу, которого не существует,  сервер выдаст ошибку или не выведет данные, что позволит понять, что такого столбца нет. Таким образом, можно узнать количество столбцов в запросе. Пример SQLi: `' ORDER BY <index (1/2/3/...)-->` 
- Количество столбцов можно узнать оператором SELECT и значением NULL, добавляя значения NULL. Когда количество NULL не равно количеству столбцов, сервер будет выводить ошибку или не выдаст ничего. Когда количество NULL будет равно количеству столбцов, приложение выведет дополнительную строку с NULL, либо выведет ошибку NullPointerException. Пример SQLi: `' UNION SELECT NULL(,NULL,NULL,...)--`
